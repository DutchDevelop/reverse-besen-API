/*
 
   Reverse engineering of the 2 bytes checksum ending each UDP packets.

We don’t have the firmware yet, but luckily in the very old APK we found a file called “test.txt”.
This file is for an ARM target according to the very first bytes (stack address, reset vector etc.),
our wallbox is an ESP32. *BUT* using “strings” we found that the firmware version respects the same
format that our box.
Even if this file is cropped, for example we don’t have the main() code nor the interrupts handler,
it was enough to contain the checksum code!

*/

/*

   Original code from Ghidra:

uint FUN_08025a5e(int param_1,ushort param_2) {
  uint uVar1;
  uint uVar2;
  
  uVar1 = 0;
  if (param_1 != 0) {
    for (uVar2 = 0; (uVar2 & 0xffff) < (uint)param_2; uVar2 = (uVar2 & 0xffff) + 1) {
      uVar1 = *(byte *)(param_1 + (uVar2 & 0xffff)) + uVar1;
    }
    uVar1 = (uVar1 & 0xffff) % 0x10000;
  }
  return uVar1;
}

*/

#include <stdio.h>

#define MAX_LEN 200
#define PK_NBR 9
unsigned char raw_packets[PK_NBR][MAX_LEN]={
"\x06\x01\x00\x32\x00\x91\x81\x10\x27\x51\x21\x95\x13\xff\xff\xff\xff\xff\xff\x00\x04\x01\x09\x2e\x00\x00\x00\x00\x00\x00\x00\x02\x40\x81\x58\x92\x58\x92\x01\x02\x02\x0d\x00\x00\x00\x00\x0b\x7b\x0f\x02\x00",
"\x06\x01\x00\x19\x00\x91\x81\x10\x27\x51\x21\x95\x13\xff\xff\xff\xff\xff\xff\x00\x03\x08\x80\x0f\x02\x00",
"\x06\x01\x00\x1b\x00\x91\x81\x10\x27\x51\x21\x95\x13\xff\xff\xff\xff\xff\xff\x01\x12\x02\x01\x08\x95\x0f\x02\x00",
"\x06\x01\x00\x3d\x00\x91\x81\x10\x27\x51\x21\x95\x13\xff\xff\xff\xff\xff\xff\x01\x06\x43\x2e\x33\x32\x35\x32\x2e\x31\x31\x32\x41\x30\x30\x38\x00\x00\x43\x2e\x33\x32\x35\x32\x2e\x31\x31\x32\x41\x30\x30\x38\x00\x00\x42\x29\x6d\x48\x0f\x78\x0f\x02\x00",
"\x06\x01\x00\x5f\x00\x91\x81\x10\x27\x51\x21\x95\x13\xff\xff\xff\xff\xff\xff\x00\x01\x01\x42\x45\x53\x45\x4e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x42\x53\x32\x30\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x43\x2e\x33\x32\x35\x32\x2e\x31\x31\x32\x41\x30\x30\x38\x00\x00\x00\x00\x1b\x80\x20\x57\x57\x57\x2e\x45\x56\x53\x45\x2e\x43\x4f\x4d\x00\x00\x00\x00\x12\x2f\x0f\x02\x00",
"\x06\x01\x00\x63\x00\x91\x81\x10\x27\x51\x21\x95\x13\xff\xff\xff\xff\xff\xff\x00\x05\x01\x0d\x31\x36\x34\x39\x34\x35\x33\x35\x32\x38\x36\x31\x38\x32\x34\x39\x01\x01\xff\xff\xff\xff\xff\xff\x62\x50\x55\x78\x38\x36\x30\x30\x37\x39\x37\x39\x38\x35\x37\x38\x39\x32\x34\x33\x0d\x62\x50\x55\x78\x00\x00\x00\x49\x00\x02\x40\x7b\x00\x02\x40\x80\x00\x00\x00\x05\x00\x00\x00\x05\x01\x00\x64\x1a\xc1\x0f\x02\x00",
"\x06\x01\x00\x1e\x00\x91\x81\x10\x27\x51\x21\x95\x13\xff\xff\xff\xff\xff\xff\x01\x01\x01\x62\x50\x5c\xdc\x0a\x6f\x0f\x02\x00",
"\x06\x01\x00\x1e\x00\x91\x81\x10\x27\x51\x21\x95\x13\xff\xff\xff\xff\xff\xff\x00\x07\x01\x00\x01\x00\x10\x08\x9b\x0f\x02\x00",
"\x06\x01\x00\x1e\x00\x91\x81\x10\x27\x51\x21\x95\x13\xff\xff\xff\xff\xff\xff\x01\x01\x01\x62\x50\x5c\xd4\x0a\x67\x0f\x02\x00"
};

unsigned int find_len(unsigned char * ptr) {

	for (int i=0; i<MAX_LEN-3 ; i++) {
		if ( ptr[i] == '\x0f' && ptr[i+1] == '\x02' && ptr[i+2] == 0 )
			return(i-2);
	}
	return(0);
}

unsigned int checksum(unsigned char * ptr, int len) {

	int sum = 0;

	for (int i=0 ; i<len; i++)
		sum += (unsigned int)ptr[i];

	return(sum % 0x10000);
}

void main() {

	unsigned int len, sum;
	for (int i=0; i<PK_NBR; i++) {

		len = find_len(raw_packets[i]);
		sum = checksum(raw_packets[i],len);
		printf("\nPacket nbr %d: original checksum %02X%02X, computed one %04X",i,raw_packets[i][len],raw_packets[i][len+1],sum);
	}
}
